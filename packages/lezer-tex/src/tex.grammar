@precedence {
  number @left,
  amalg_math_shift @left
}

@dialects {
  directives
}

@top Document { statement+ }

statement {
  // Logical
  if_statement |
  
  // Groups
  simple_group |
  semi_simple_group |
  math_shift_group |

  // Commands
  let_cmd |
  futurelet_cmd |
  def_cmd |
  defcode_cmd |

  // Tokens
  tab_mark |
  car_ret |
  mac_param |
  sup_mark |
  sub_mark |
  ignore |
  spacer |
  letter |
  other_char |
  active_char |
  invalid_char |

  control_sequence |
  directive
}

// Groups
simple_group {
  left_brace statement* right_brace
}
semi_simple_group {
  begingroup_cs statement* endgroup_cs
}
math_shift_group[@name="math_shift_group"] {
  ordinary_math_mode | display_math_mode
}
ordinary_math_mode {
  single_math_shift !amalg_math_shift statement* single_math_shift
}
display_math_mode {
  double_math_shift !amalg_math_shift statement* double_math_shift
}

// Commands
let_cmd {
  prefix_cs* let_cs
    spacer* control_sequence
    (spacer* optional_equal)?
    spacer* control_sequence
}
futurelet_cmd {
  prefix_cs* futurelet_cs
    spacer* control_sequence
    spacer* control_sequence
    spacer* control_sequence
}
defcode_cmd {
  prefix_cs* defcode_cs
    spacer* integer
    (spacer* optional_equal)?
    spacer* integer
}
def_cmd {
  prefix_cs* def_cs simple_group
}

// Logical
if_statement {
  if_cs statement* (else_cs statement*)* fi_cs
}

/**
 * Tokens
 *
 * In TeX, a token is defined as as a triple (cur_cmd, cur_chr, cur_cs):
 *
 * - cur_cmd: the current control_sequence
 * - cur_chr: the operand of the current control_sequence
 * - cur_cs: the control sequence
 *
 * With these three, two combinations are defined:
 *
 * 1. cur_cs == 0
 * 2. cur_cs != 0
 *
 * For the first type, TeX encodes this as a character with a category. For the second type, TeX
 * encodes this as a sequence of category 11 characters after a category 0 character or a single
 * character from any category after a category 0 character.
 */
@skip { line_comment }
@context trackContext from "../tokens"
@external tokens tokenizer from "../tokens" {
  // escape[@name="escape"], Every escape prefixes a control sequence, so we don't handle this singularly.
  left_brace[@name="left_brace",closedBy="right_brace"],
  right_brace[@name="right_brace",openedBy="left_brace"],
  math_shift[@name="math_shift"],
  tab_mark[@name="tab_mark"],
  car_ret[@name="car_ret"],
  mac_param[@name="mac_param"],
  sup_mark[@name="sup_mark"],
  sub_mark[@name="sub_mark"],
  ignore[@name="ignore"],
  spacer, // These should be named `spacer`, but for simplicity of the tree, we leave it hidden.
  letter, // These should be named `letter`, but for simplicity of the tree, we leave it hidden.
  other_char, // These should be named `other_char`, but for simplicity of the tree, we leave it hidden.
  active_char[@name="active_char"],
  // comment[@name="comment"],Every comment prefixes a comment, so we don't handle this singularly.
  invalid_char[@name="invalid_char"],

  control_sequence_token,
  begingroup_cs_token,
  endgroup_cs_token,
  defcode_cs_token,
  def_cs_token,
  let_cs_token,
  futurelet_cs_token, // Futurelet is significantly then let, so we handle let and future let separately.
  prefix_cs_token,
  if_cs_token,
  or_cs_token,
  else_cs_token,
  fi_cs_token,

  // A `directive` is a parser rule that provides custom parser runtime functionalities in the form of
  // comments. They come in the form of `%! <abstract command>` where `<abstract command>` is
  // predefined in the tokenizer. E.g. `%! Change category code for code point 64 to 11.`. The
  // semantic behind `<abstract command>` is reminiscent of Knuth's WEB language; the directive is
  // still a comment, so it should remain semantic although functional.
  directive_comment[@dialect="directives"],
  line_comment
}

control_sequence[@name="control_sequence"] {
  control_sequence_token
}
begingroup_cs[@name="begingroup_cs"] {
  begingroup_cs_token
}
endgroup_cs[@name="endgroup_cs"] {
  endgroup_cs_token
}
defcode_cs[@name="defcode_cs"] {
  defcode_cs_token
}
def_cs[@name="def_cs"] {
  def_cs_token
}
let_cs[@name="let_cs"] {
  let_cs_token
}
futurelet_cs[@name="futurelet_cs"] {
  futurelet_cs_token
}
prefix_cs[@name="prefix_cs"] {
  prefix_cs_token
}
if_cs[@name="if_cs"] {
  if_cs_token
}
or_cs[@name="or_cs"] {
  or_cs_token
}
else_cs[@name="else_cs"] {
  else_cs_token
}
fi_cs[@name="fi_cs"] {
  fi_cs_token
}

directive[@name="directive"] {
  directive_comment
}

single_math_shift[@name="single_math_shift",closedBy="single_math_shift",openedBy="single_math_shift"] { math_shift !amalg_math_shift }
double_math_shift[@name="double_math_shift",closedBy="double_math_shift",openedBy="double_math_shift"] { math_shift math_shift }
optional_equal[@name="optional_equal"] { @extend<other_char, "="> }
any_char {
  left_brace | right_brace | math_shift | tab_mark | car_ret | mac_param | sup_mark | sub_mark |
  ignore | letter | other_char | active_char | invalid_char
}

// TeX numbers
integer[@name="integer"] { sign* (dec_number | oct_number | hex_number | alpha_number) }

// The sign of an integer
sign { @extend<other_char, "+" | "-"> }

// Various types of digits
oct_digit { @extend<other_char, "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8"> }
dec_digit { oct_digit | @extend<other_char, "9"> }
hex_digit { dec_digit | @extend<other_char, "A" | "B" | "C" | "D" | "E" | "F"> | @extend<letter, "A" | "B" | "C" | "D" | "E" | "F"> }

// Numbers in various bases
dec_number { dec_digit+ !number }
oct_number { @extend<other_char, "'"> oct_digit+ !number }
hex_number { @extend<other_char, "\""> hex_digit+ !number }
alpha_number { @extend<other_char, "`"> (control_sequence | active_char | any_char) !number }
