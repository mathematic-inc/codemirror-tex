@precedence {
  number @left
}

@dialects {
  directives
}

@top Document { statement+ }

statement {
  // Groups
  bracket_group |

  // Commands
  // let_cmd |
  // futurelet_cmd |
  // def_code_cmd |

  // Tokens
  escape |
  math_shift |
  tab_mark |
  car_ret |
  mac_param |
  sup_mark |
  sub_mark |
  ignore |
  spacer |
  letter |
  other_char |
  active_char |
  invalid_char |

  control_sequence |
  directive
}

// Groups
bracket_group {
  left_brace statement* right_brace
}

// Commands
let_cmd[@name="let_cmd"] {
  @specialize<control_sequence_token, "let"> spacer* control_sequence (spacer* optional_equal)? spacer* control_sequence
}
futurelet_cmd[@name="futurelet_cmd"] {
  @specialize<control_sequence_token, "futurelet"> spacer* control_sequence spacer* control_sequence spacer* control_sequence
}
def_code_cmd[@name="def_code_cmd"] {
  @specialize<control_sequence_token, "catcode">  spacer* integer (spacer* optional_equal)? spacer* integer
}


/**
 * Tokens
 *
 * In TeX, a token is defined as as a triple (cur_cmd, cur_chr, cur_cs):
 *
 * - cur_cmd: the current control_sequence
 * - cur_chr: the operand of the current control_sequence
 * - cur_cs: the control sequence
 *
 * With these three, two combinations are defined:
 *
 * 1. cur_cs == 0
 * 2. cur_cs != 0
 *
 * For the first type, TeX encodes this as a character with a category. For the second type, TeX
 * encodes this as a sequence of category 11 characters after a category 0 character or a single
 * character from any category after a category 0 character.
 */
@skip { line_comment }
@context trackContext from "../tokenizer"
@external tokens tokenizer from "../tokenizer" {
  escape[@name="escape"],
  left_brace[@name="left_brace"],
  right_brace[@name="right_brace"],
  math_shift[@name="math_shift"],
  tab_mark[@name="tab_mark"],
  car_ret[@name="car_ret"],
  mac_param[@name="mac_param"],
  sup_mark[@name="sup_mark"],
  sub_mark[@name="sub_mark"],
  ignore[@name="ignore"],
  spacer, // These should be named `spacer`, but for simplicity of the tree, we leave it hidden.
  letter, // These should be named `letter`, but for simplicity of the tree, we leave it hidden.
  other_char, // These should be named `other_char`, but for simplicity of the tree, we leave it hidden.
  active_char[@name="active_char"],
  comment[@name="comment"],
  invalid_char[@name="invalid_char"],

  control_sequence_token,

  // A `directive` is a parser rule that provides custom parser runtime functionalities in the form of
  // comments. They come in the form of `%! <abstract command>` where `<abstract command>` is
  // predefined in the tokenizer. E.g. `%! Change category code for code point 64 to 11.`. The
  // semantic behind `<abstract command>` is reminiscent of Knuth's WEB language; the directive is
  // still a comment, so it should remain semantic although functional.
  directive_comment,
  line_comment
}

control_sequence[@name="control_sequence"] {
  control_sequence_token
}

directive[@name="directive"] {
  directive_comment
}

optional_equal[@name="optional_equal"] { @extend<other_char, "="> }
any_char {
  left_brace | right_brace | math_shift | tab_mark | car_ret | mac_param | sup_mark | sub_mark |
  ignore | letter | other_char | active_char | invalid_char
}

// TeX numbers
integer[@name="integer"] { sign* (dec_number | oct_number | hex_number | alpha_number) }

// The sign of an integer
sign { @extend<other_char, "+" | "-"> }

// Various types of digits
oct_digit { @extend<other_char, "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8"> }
dec_digit { oct_digit | @extend<other_char, "9"> }
hex_digit { dec_digit | @extend<other_char, "A" | "B" | "C" | "D" | "E" | "F"> | @extend<letter, "A" | "B" | "C" | "D" | "E" | "F"> }

// Numbers in various bases
dec_number { dec_digit+ !number }
oct_number { @extend<other_char, "'"> oct_digit+ !number }
hex_number { @extend<other_char, "\""> hex_digit+ !number }
alpha_number { @extend<other_char, "`"> (control_sequence | active_char | any_char) !number }
